<html>
<head>
    <script src="node_modules/three/build/three.min.js"></script>
    <script src="node_modules/lodash/lodash.js"></script>
    <script src="node_modules/three-map-controls/lib/three-map-controls.js"></script>
    <script src="rbush.min.js"></script>
    <style>
        body{
            margin: 0px;
        }

        canvas{
            position: absolute;
        }

        canvas:last-of-type{
            pointer-events: none;
        }

        .hud{
            position: absolute;
        }

        .hud .leaf-nodes li{
            color: white;
        }
    </style>
</head>

<body>
<script type="text/javascript">
    (function(container){
        var camera, scene, renderer,
            spriteRenderer, spriteScene, rbush,
            rbushData;
        var meshes = [];
        var dims = 10;

        var displayedLeafLis = {};
        var hudEl, leavesList, parentNodesList;
        var activeObjects = [],
            activeNodes = [];

        init();
        animate();



        function updateData(){
            var selectedHeight = 1;
            var center = camera.position.clone();

            activeObjects = [];
            activeNodes = [];

            center.z = 0;

            var vOffset = Math.tan((camera.fov * Math.PI / 180) / 2) * camera.position.z;
            var hOffset = vOffset * camera.aspect;

            var bottomLeft = new THREE.Vector3(center.x - hOffset, center.y - vOffset, 0 );
            var topRight = new THREE.Vector3(center.x + hOffset, center.y + vOffset, 0 );

            var _res = rbush.search({minX: bottomLeft.x, minY: bottomLeft.y, maxX: topRight.x, maxY: topRight.y});

            activeObjects = _res.leafNodes;

            var grouping_nodes = _res.parentNodes[selectedHeight];
            activeNodes = (grouping_nodes)? Object.keys(grouping_nodes) : null;
        }

        function updateHUD(){

            var _activeIds = [];

            _.each(activeObjects, function(leafNode){
                var _el;

                _activeIds.push(leafNode.store.num);

                if(displayedLeafLis[leafNode.store.num] === undefined){
                    _el = document.createElement('LI');
                    displayedLeafLis[leafNode.store.num] = _el;
                    _el.innerText = String(leafNode.store.num);
                    leavesList.appendChild(_el);
                }
            });

            var _displayed = Object.keys(displayedLeafLis);
            _.each(_displayed, function(id){
                if(_activeIds.indexOf(parseInt(id)) < 0){
                    displayedLeafLis[id].parentNode.removeChild(displayedLeafLis[id]);
                    delete displayedLeafLis[id];
                }
            });

        };

        function initHUD(){
            hudEl = document.createElement('DIV');
            hudEl.className = "hud";

            //append container to list active leaf-nodes
            leavesList = document.createElement('UL');
            leavesList.className = "leaf-nodes";
            hudEl.appendChild(leavesList);

            parentNodesList = document.createElement('UL');
            parentNodesList.className = "parent-nodes";
            hudEl.appendChild(parentNodesList);

            var heightControls = document.createElement('div');
            heightControls.className = "height-controls";
            hudEl.appendChild(heightControls);

            document.body.appendChild(hudEl);
        };

        function init(){
            rbush = window.rbush(5);
            rbushData = [];

            camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
            camera.position.z = 20;

            scene = new THREE.Scene();
            spriteScene = new THREE.Scene();

            var offset = 2;
            var cubeDims = 1;

            for(var x = 0; x < dims; x++){
                for(var y = 0; y < dims; y++){

                    var canvas = document.createElement('canvas');
                    var size = 256;

                    canvas.width = size;
                    canvas.height = size;

                    var context = canvas.getContext('2d');

                    var geometry = new THREE.CubeGeometry(cubeDims, cubeDims, cubeDims);
                    var material = new THREE.MeshNormalMaterial();

                    var mesh = new THREE.Mesh( geometry, material );
                    mesh.position.x += ((-0.5 * dims * (cubeDims + offset)) + (x * (cubeDims + offset)));
                    mesh.position.y += ((-0.5 * dims * (cubeDims + offset)) + (y * (cubeDims + offset)));

                    meshes.push(mesh);

                    context.clearRect(0, 0, canvas.width, canvas.height);
                    context.fillStyle = '#ff0000'; // CHANGED
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.font = '32px Arial';

                    var cubeNumber = (((dims - y) * dims) + x) - dims;

                    rbushData.push({
                        minX: mesh.position.x,
                        minY: mesh.position.y,
                        maxX: mesh.position.x + cubeDims,
                        maxY: mesh.position.y + cubeDims,
                        store: {num: cubeNumber}
                    });

                    context.fillText(cubeNumber.toString(), size / 2, size / 2);

                    var numberTexture = new THREE.Texture(canvas);
                    numberTexture.needsUpdate = true;

                    var mat = new THREE.SpriteMaterial({
                        map: numberTexture,
                        transparent: false,
                        color: 0xffffff // CHANGED
                    });

                    var sp = new THREE.Sprite(mat);
                    sp.scale.set( 10, 10, 1 );
                    sp.position.copy(mesh.position);

                    spriteScene.add( sp );
                    scene.add( mesh );
                }
            }

            rbush.load(rbushData);

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );

            //seperate renderer for sprites so that we can stick them right in the center (middle) of 3d geometry and
            //always display them above everything else. For a simple example, it works.

            //(makes it so the number-sprites are always right atop the shapes they represent, no matter the camera's
            //orientation)
            spriteRenderer = new THREE.WebGLRenderer({ alpha: true });
            spriteRenderer.setPixelRatio( window.devicePixelRatio );
            spriteRenderer.setSize( window.innerWidth, window.innerHeight );

            container.appendChild( renderer.domElement );
            container.appendChild( spriteRenderer.domElement );

            new THREE.MapControls( camera, renderer.domElement, {
                target: new THREE.Plane(new THREE.Vector3(0,0,1), 0),
                minDistance: 2.0,
                maxDistance: 20
            });

            initHUD();

            window.addEventListener( 'resize', onWindowResize, false );
        }

        function onWindowResize(){
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );
            spriteRenderer.setSize( window.innerWidth, window.innerHeight );
        }

        function animate(){
            requestAnimationFrame( animate );

            _.each(meshes, function( mesh ){
                mesh.rotation.x += 0.005;
                mesh.rotation.y += 0.01;
            });

            renderer.render( scene, camera );
            spriteRenderer.render( spriteScene, camera );
            updateData();
            updateHUD();
        }
    })(document.body);
</script>
</body>
</html>